# 操作文件与目录
## ln 创建链接
### 硬链接
不能应用不同磁盘的文件，不能引用目录。本身与文件没有什么不同
删除这个链接文件本身存在（空间未释放）当该文件所有链接都被删除才被释放
### 符号链接
通过创建一个特殊类型的文件来起作用，包含指向引用文件或目录的文件指针
有点类似于win中的快捷方式
如果链接指向的文件被删除了，链接自己还在，就是一个坏链接，在ls时会以红色显示

* 使用`cp -i`来进行交互式询问（是否覆盖文件等系统提示）
* `ln fun fun-hard`为fun创建一个硬链接
* `ln -s fun fun-sym`为fun创建一个软链接

# 命令的使用
## 什么是命令
* 可执行程序，可以是二进制文件，如用C编写的。或者用shell,python等脚本语言写的文本
* shell 内置命令bash内部称之为shell builtin的内置命令，比如cd
* shell函数 合并在环境变量中的小型shell脚本
* alias命令。在其他命令的基础上定义自己的命令

## 识别命令
type<br>
查看命令的类型如
```
type type
type ls
type cp
```
会得到三个不同的结果，会发现ls实际上是-color=tty的ls的别名<br>
which——显示可执行程序位置

## 获取命令文档
help——获取内置命令帮助，如
```
help cd
```
help——显示使用信息
```
cd --help
```
man——显示程序手册页，注意man是调用less命令来显示手册文档，所有less命令都可以奏效。
apropos——显示合适的命令，匹配合适的命令
```
apropos floppy
```
whatis——显示命令的简要描述，显示手册页的名字和一行描述
info——显示程序的info条目，用于代替手册文档，页面使用了超链接，是树形结构。操作如下
| 命令 | 功能 |
| --- | --- |
| ? | 显示命令帮助|
| page up/down | 翻页 |
| n/p | 下一个节点、上一个节点 |
| u | 进入父节点 |
| ENTER | 进入超链接 |
|q | 退出 |

## 使用别名创造自己的命令
* 小技巧：使用分号分隔命令，可以在一行写多条命令

创造命令前需要用type测试该命令是否已经存在，没有存在，则可以使用alias来创建命令。删除别名使用unalias.实例如下
```
type foo
alias foo='cd /usr;ls;cd -'
foo
type foo
unalis foo
```

# 重定向
与UNIX一切是文件的思想一致，程序运行的输出结果实际上是发送到了标准输出(standard output,通常为stdout)。状态信息被发送到标准错误(standard eooro,stderr)中。默认情况下标准输出和标准错误都被连接到屏幕上，不会被保存在磁盘中<br>
许多程序从标准输入(standard input,stdin)中得到输出，默认情况下连接到键盘。重定向则是改变输入输出的来源/目的地
## 标准输出重定向
1. \>
    <br>把标准输出重定向到一个文件中。如果运行时产生了错误，大多数写得很好的UNIX程序会把错误信息发送到标准错误文件中。只重定向标准输出的话，文件里会收不到信息。使用`> output.txt`可以把一个文件变成空文件或者创建一个新文件。
2. \>\>
    <br>使用\>\>可以不覆盖原有文件，而是把内容添加到文件尾部
3. 标准错误重定向
    <br>shell内部用文件描述符来描述，使用索引来标记：0是标准输入文件，1是标准输出文件，2是标准错误文件，需要列出错误时应该写作：
    ```
    ls -l /bin/usr 2>ls-error.txt
    ```
4. 把标准输入和输出定向到同一个文件
<br>很多时候会这样做，传统方法如下
```
ls -l > ls-output.txt 2>&1
```
这样，首先会重定向标准输出到文件中，然后把文件描述符2定向到文件描述符1。这样会先输出标准输出再输出错误。注意，顺序是很重要的，标准错误的重定向操作通常发生在标准输出重定向后，否则就没用了。如果改为2>&1>ls-output.txt，那么标准错误会定向到屏幕。最近的bash提供了更好的写法：
```
ls -l &> ls-output.txt
```
只要使用`&>`即可

5. 处理不想要的输出
<br>当不希望得到输出时，应该重定向到/dev/null这个文件中，这个文件是叫位桶(bit bucket)的系统设备,接受输入但是不对输入做任何处理
```
ls -l > /dev/null
```
6. 标准输入重定向
> cat 合并文件：读取一个或多个文件，把它们复制到标准输出文件中。可以一次性合并很多文件：
```
cat movie.mpeg.0* >movie.mpeg    
```
>通常通配符是按照顺序扩展的，这样可以直接拼在一起。如果只输入cat而没有参数，会一直不懂，实际上它正在执行功能：就是从标准输入接受输入，可以按下Ctrl-D来告诉它输入完毕。可以尝试下面的操作：
```
root@qyh:/home/learn_shell# cat >lazy.txt
The quick brown fox jumped over the lazy dog
(这里按下Ctrl-D)
```
## 管道
把一个命令的标准输出传到另一个命令的标准输入<br>
*command1* | *command2*
```
ls -l | less
```

1. 过滤器<br>
把多条命令合在一起变成一个管道，通常成为过滤器，如
```
ls | sort | less
```
2. uniq——报告或忽略文件中重复的行。不加参数就是忽略，加-d查看

3. wc 打印行数、字数、字节数

4. grep 打印匹配行<br>
grep *pattern* [*file*...]<br>
选项有-i,忽略大小写；-v 反选，选出不匹配的

5. head/tail ——打印文件开头和结尾，用-n num 来指定数量
<br> 使用f选项，tail就会持续观察文件产生的新行，直到使用Ctrl-C停止。有的发行版会要求超级用户权限

6. tee——从stdin读取数据，同时输出到stdout和文件。就像安装了一个"T"在管道上，读取了输入后把内容复制成两份，一份给文件一份给stdout

# shell一些比较杂的事项
## 扩展
使用`echo *` 会看到输出不是*，而是当前文件夹下的文件，这是因为*的含义是匹配文件名中的任意字符，按下ENTER,shell会在执行命令之前扩展命令行中符合条件的字符。

1. 路径名扩展
```
echo D*
```

2. 波浪线扩展：~是当前用户主目录，如果有foo这个用户，那么~foo就会显示这个用户的主目录

3. 算数扩展，允许把shell当作计算器，但是只支持整数的加减乘除，取余，幂(**)
```
echo $((2+2))
```
4. 花括号扩展<br>
可以按花括号内的模式创建多种字符串,可以取范围值，可以嵌套。主要应用在一些列文件和目录的管理
```
echo Front-{A,B,C}-Back
echo Number_{1..5}
echo {Z..A}
echo a{A{1,2},B{3.4}}b
```

5. 参数扩展（之后会更深入介绍）
<br>`echo $USER`可以看到当前用户。可以查看可用变量列表`printenv | less`

6. 命令替换
<br> 比如`echo $(ls)`,可以直接使用命令的输出

## 引用
使用引用机制避免不必要的扩展
1. ""
<br> 除了$,\,`外的扩展失效（如单词分割、路径名、花括号、波浪线）

2. ''
<br>所有扩展都会失效

3. 转义字符，可以在双引号中选择性阻止扩展。在echo命令中加上-e,就可以解释转义字符

## 编辑命令行
有一些光标移动、修改文本、复制粘贴的命令。

## 自动补齐
使用Tab自动补齐，按两次显示可能的补齐列表。现在的命令行可以有可编程的自动补齐。比如ubuntu就定义了一个相当大的规则合集，使用set可以查看。

## 历史命令
history查看所有历史，历史保存在用户主目录.bash_history中。可以自己用grep等筛选.<br>
`！88`可以扩展为历史列表第88行。按下Ctrl-R可以递增式搜索历史记录，Ctrl-J可以把搜索到的记录复制到当前命令行。操作要用再看
* 历史记录扩展<br>
!! 重复最后一个执行的命令；！num 历史中第num行命令;! str,重复最近的以str开头的记录；！？str，重复最近的包含str的历史记录

# 权限