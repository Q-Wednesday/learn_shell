# 操作文件与目录
## ln 创建链接
### 硬链接
不能应用不同磁盘的文件，不能引用目录。本身与文件没有什么不同
删除这个链接文件本身存在（空间未释放）当该文件所有链接都被删除才被释放
### 符号链接
通过创建一个特殊类型的文件来起作用，包含指向引用文件或目录的文件指针
有点类似于win中的快捷方式
如果链接指向的文件被删除了，链接自己还在，就是一个坏链接，在ls时会以红色显示

* 使用`cp -i`来进行交互式询问（是否覆盖文件等系统提示）
* `ln fun fun-hard`为fun创建一个硬链接
* `ln -s fun fun-sym`为fun创建一个软链接

# 命令的使用
## 什么是命令
* 可执行程序，可以是二进制文件，如用C编写的。或者用shell,python等脚本语言写的文本
* shell 内置命令bash内部称之为shell builtin的内置命令，比如cd
* shell函数 合并在环境变量中的小型shell脚本
* alias命令。在其他命令的基础上定义自己的命令

## 识别命令
type<br>
查看命令的类型如
```
type type
type ls
type cp
```
会得到三个不同的结果，会发现ls实际上是-color=tty的ls的别名<br>
which——显示可执行程序位置

## 获取命令文档
help——获取内置命令帮助，如
```
help cd
```
help——显示使用信息
```
cd --help
```
man——显示程序手册页，注意man是调用less命令来显示手册文档，所有less命令都可以奏效。
apropos——显示合适的命令，匹配合适的命令
```
apropos floppy
```
whatis——显示命令的简要描述，显示手册页的名字和一行描述
info——显示程序的info条目，用于代替手册文档，页面使用了超链接，是树形结构。操作如下
| 命令 | 功能 |
| --- | --- |
| ? | 显示命令帮助|
| page up/down | 翻页 |
| n/p | 下一个节点、上一个节点 |
| u | 进入父节点 |
| ENTER | 进入超链接 |
|q | 退出 |

## 使用别名创造自己的命令
* 小技巧：使用分号分隔命令，可以在一行写多条命令

创造命令前需要用type测试该命令是否已经存在，没有存在，则可以使用alias来创建命令。删除别名使用unalias.实例如下
```
type foo
alias foo='cd /usr;ls;cd -'
foo
type foo
unalis foo
```

# 重定向
与UNIX一切是文件的思想一致，程序运行的输出结果实际上是发送到了标准输出(standard output,通常为stdout)。状态信息被发送到标准错误(standard eooro,stderr)中。默认情况下标准输出和标准错误都被连接到屏幕上，不会被保存在磁盘中<br>
许多程序从标准输入(standard input,stdin)中得到输出，默认情况下连接到键盘。重定向则是改变输入输出的来源/目的地
## 标准输出重定向
1. \>
    <br>把标准输出重定向到一个文件中。如果运行时产生了错误，大多数写得很好的UNIX程序会把错误信息发送到标准错误文件中。只重定向标准输出的话，文件里会收不到信息。使用`> output.txt`可以把一个文件变成空文件或者创建一个新文件。
2. \>\>
    <br>使用\>\>可以不覆盖原有文件，而是把内容添加到文件尾部
3. 标准错误重定向
    <br>shell内部用文件描述符来描述，使用索引来标记：0是标准输入文件，1是标准输出文件，2是标准错误文件，需要列出错误时应该写作：
    ```
    ls -l /bin/usr 2>ls-error.txt
    ```
4. 把标准输入和输出定向到同一个文件
    <br>很多时候会这样做，传统方法如下
    ```
    ls -l > ls-output.txt 2>&1
    ```
这样，首先会重定向标准输出到文件中，然后把文件描述符2定向到文件描述符1。这样会先输出标准输出再输出错误。注意，顺序是很重要的，标准错误的重定向操作通常发生在标准输出重定向后，否则就没用了。如果改为2>&1>ls-output.txt，那么标准错误会定向到屏幕。最近的bash提供了更好的写法：
```
ls -l &> ls-output.txt
```
只要使用`&>`即可

5. 处理不想要的输出
    <br>当不希望得到输出时，应该重定向到/dev/null这个文件中，这个文件是叫位桶(bit bucket)的系统设备,接受输入但是不对输入做任何处理
    ```
    ls -l > /dev/null
    ```
6. 标准输入重定向
    > cat 合并文件：读取一个或多个文件，把它们复制到标准输出文件中。可以一次性合并很多文件：
    ```
    cat movie.mpeg.0* >movie.mpeg    
    ```
    >通常通配符是按照顺序扩展的，这样可以直接拼在一起。如果只输入cat而没有参数，会一直不懂，实际上它正在执行功能：就是从标准输入接受输入，可以按下Ctrl-D来告诉它输入完毕。可以尝试下面的操作：
    ```
    root@qyh:/home/learn_shell# cat >lazy.txt
    The quick brown fox jumped over the lazy dog
    (这里按下Ctrl-D)
    ```
## 管道
把一个命令的标准输出传到另一个命令的标准输入<br>
*command1* | *command2*
```
ls -l | less
```

1. 过滤器<br>
    把多条命令合在一起变成一个管道，通常成为过滤器，如
    ```
    ls | sort | less
    ```
2. uniq——报告或忽略文件中重复的行。不加参数就是忽略，加-d查看

3. wc 打印行数、字数、字节数

4. grep 打印匹配行<br>
grep *pattern* [*file*...]<br>
选项有-i,忽略大小写；-v 反选，选出不匹配的

5. head/tail ——打印文件开头和结尾，用-n num 来指定数量
<br> 使用f选项，tail就会持续观察文件产生的新行，直到使用Ctrl-C停止。有的发行版会要求超级用户权限

6. tee——从stdin读取数据，同时输出到stdout和文件。就像安装了一个"T"在管道上，读取了输入后把内容复制成两份，一份给文件一份给stdout

# shell一些比较杂的事项
## 扩展
使用`echo *` 会看到输出不是*，而是当前文件夹下的文件，这是因为*的含义是匹配文件名中的任意字符，按下ENTER,shell会在执行命令之前扩展命令行中符合条件的字符。

1. 路径名扩展
    ```
    echo D*
    ```

2. 波浪线扩展：~是当前用户主目录，如果有foo这个用户，那么~foo就会显示这个用户的主目录

3. 算数扩展，允许把shell当作计算器，但是只支持整数的加减乘除，取余，幂(**)
    ```
    echo $((2+2))
    ```
4. 花括号扩展<br>
可以按花括号内的模式创建多种字符串,可以取范围值，可以嵌套。主要应用在一些列文件和目录的管理
    ```
    echo Front-{A,B,C}-Back
    echo Number_{1..5}
    echo {Z..A}
    echo a{A{1,2},B{3.4}}b
    ```

5. 参数扩展（之后会更深入介绍）
<br>`echo $USER`可以看到当前用户。可以查看可用变量列表`printenv | less`

6. 命令替换
<br> 比如`echo $(ls)`,可以直接使用命令的输出

## 引用
使用引用机制避免不必要的扩展
1. ""
<br> 除了$,\,`外的扩展失效（如单词分割、路径名、花括号、波浪线）

2. ''
<br>所有扩展都会失效

3. 转义字符，可以在双引号中选择性阻止扩展。在echo命令中加上-e,就可以解释转义字符

## 编辑命令行
有一些光标移动、修改文本、复制粘贴的命令。

## 自动补齐
使用Tab自动补齐，按两次显示可能的补齐列表。现在的命令行可以有可编程的自动补齐。比如ubuntu就定义了一个相当大的规则合集，使用set可以查看。

## 历史命令
history查看所有历史，历史保存在用户主目录.bash_history中。可以自己用grep等筛选.<br>
`！88`可以扩展为历史列表第88行。按下Ctrl-R可以递增式搜索历史记录，Ctrl-J可以把搜索到的记录复制到当前命令行。操作要用再看
* 历史记录扩展<br>
!! 重复最后一个执行的命令；！num 历史中第num行命令;! str,重复最近的以str开头的记录；！？str，重复最近的包含str的历史记录

# 权限

传统UNIX操作系统是多用户的，同时可以让多个用户用同一个系统（比如服务器），这是深嵌在传统操作系统中的思想，因为以前的计算机体积庞大。所以系统设计成了多用户模式来保证用户之间不干扰。

## 所有者、组成员、其他所有用户

在UNIX中，一个用户可以拥有文件和目录，当他拥有时，他对这些文件的访问有控制权。而用户又归属于群组，群组由一个人或多个用户组成，可以向组授权，也可以向其他所有用用户授权。使用id命令可以获得用户身份标识的相关信息。
```
id
输出:uid= gid=  groups=
```
每个用户都有一个uid与其名字一一映射，同时用户被分配到一个有效组id,gid,该用户可以归属于其他群组。
<br>列出的信息来自于一系列文本文件，用户账户定义在/etc/passwd 中，用户组定义在/etc/group中。创建用户账户和群组的时候，这些文件会随着/etc/shadow改变。passwd定义了用户的登录名，uid,gid,主目录...

## 读取、写入和执行

使用`ls -l`列出文件，前10个字母表示文件属性，第一个是file type:
| 属性 | 文件类型 |
| --- | --- |
| - | 普通文件 |
| d | 目录 |
| l | 符号链接 |
| c | 字符设备文件，表示以字节流形式处理数据的设备 |
| b | 块设备文件，表示以数据块方式处理的设备，如硬盘驱动 |

剩下的九个字符是文件模式file mode,表示所有者、所属群组、其他所有用户对文件的读写和执行权。r:对于文件，可以打开和读取，对于目录，可以列出目录下内容；w: 允许写入或截短文件 ；x：允许执行文件，需要文件被设置为可读，对于目录，允许进入目录。注意符号链接的权限属性都是伪的，真正的权限由所指文件决定。

1. chmod——更改文件模式
<br>只有文件的所有者和超级用户可以更改。有八进制和符号两种改法。<br>
八进制可以表示权限，因为八进制正好对应三个二进制数字，rwx就是7，r-x就是5.通过三位八进制，可以把权限赋给，所有者、组成员和其他所有用户(world)
如
    ```
    chmod 600 foo.txt
    ```
    把foo.txt设为了仅当前用户可读写<br>
    符号表示，通过u,g,o,a指定更改对象。u：用户；g：文件所属群组；o：其他所有用户；a：包括前三者
    <br>没有指定字符时默认使用a,+表示添加权限，-表示删除，=表示指定权限。权限由r,w,x来指定。如`u+x`：给当前用户添加执行的权限
2. GUI设置文件模式
3. umask 设置默认权限<br>
控制创建文件的时候给的默认权限，用八进制表示法来表示从文件模式属性中删除一个位掩码。比给定掩码0022,展开为八进制：<br>
000 000 010 010<br>
假设原来的权限为--- rw- rw- rw-,掩码为1的位置对应权限就被删除，就变为--- rw- rw- r--<br>
大多数情况都不要改变掩码，用默认就好。在一些高级的安全环境下需要控制。

实际上还有一些特殊的权限，通常八进制权限掩码用三位数表现，但是从技术层面上来说应该用四位数，如4000表示setuid位等等。需要用的时候可以去详细了解。

## 更改身份
1. su——用其他用户和组ID的身份运行shell<br>
命令形式为su [-[l]] [ *user* ].包含-l的时候，得到的会话界是用于指定用户的登陆界面，意味着会加载该用户的运行环境，工作目录也会改到该用户的主目录。默认指定超级用户。-l可以简写为-，所以用su -就能登陆到超级用户。使用exit返回到之前的操作环境。也可以用su执行单个命令而不开启新的交互式命令。格式为 `su -c 'command' `

2. sudo——用另一个用户的身份执行命令<br>
管理者可以通过配置sudo命令让系统以一种可控得方式允许一个普通用户可以以不同的用户身份（通常是超级用户）执行命令。可以限制用户只能执行几条特殊的命令。与su的区别在于，sudo是不需要输入超级用户密码的，只要输入自己的密码验证。

3. chown——更改文件所有者和所属群组<br>
使用这个命令要超级用户权限，chown [ *owner* ][: [ *group* ]] *file* ...
<br>bob:users 把所有者换为bob,所有群组换为users
<br>:admins 不改变所有者，改变群组
<br>bob: 所有者改为bob,群组为bob登陆的群组

4. chgrp——更改文件所属群组

## 权限的使用
## 更改用户密码
passwd [ *user* ]<br>
设置/更改密码，如果要更改用户自己的密码，只要输入psaawd。会强制用户使用强密码，拒绝接受太短的密码


# 进程
现代操作系统都支持多重任务处理，实际上是系统快速切换运行中的程序来实现多任务共同执行，Linux内行人使用进程管理多重任务。进程是Linux用来安排不同程序等待CPU调度的一种组织方式。

## 进程如何工作
系统启动的时候，内行人把一些程序初始化为进程，运行名为init的程序，init依次运行一些列脚本初始化(init script)的shell脚本，这些脚本放在/etc下，这些脚本启动所有的系统服务，很多服务都是守护程序(daemon program)。这些后台程序在后台默默执行。<br>
一个程序的运行可以触发其他程序的运行，在进程系统中被表达为父进程创建子进程。<br>
内核可以保存每个程序的信息以便任务有序进行，比如每个进程都会被分配ID(PID,process ID)的号码。按递增顺序分配ID,init的PID始终为1。内核也记录分配给进程的内存信息以及用来恢复运行的进程就绪信息。和文件系统类似，进程系统存在所有者，用户ID，有效用户ID。

1. 使用ps查看进程信息<br>
TTY是teletype的缩写，表示进程的控制终端。TIME表示进程消耗CPU的时间总和。添加x选项（ps x），告诉ps显示所有的进程，且不需要关注它们由那个终端控制。STAT表示进程当前状态。<br>
R表示运行，S是睡眠，D是不可中断的睡眠（等待I/O操作），T为暂停（后续可以继续），Z是僵尸进程，子进程被终止但还没被父进程释放。<是高级优先进程，被分配更多的CPU时间.N是低优先级（a nice process,友好的进程），只有在其他高优先级处理完后才获得CPU时间。<br>
可以查看ps的帮助界面获得更多信息，一个常用的选项是aux(不要连字符)，可以输出更多信息

2. 使用top动态查看进程信息<br>
按照进程活动顺序用列表的形式持续显示系统进程(默认3秒更新一次)。top可以接受许多键盘指令，h是帮助，q退出。类似win的任务管理器。在顶部显示总体状态信息，一天当中的时间、正常运行时间等等。

## 控制进程

1. 中断 Ctrl+C
2. 后台运行 在命令后加&,如 `xlogo &`<br>
shell的作业控制(jobs control),使用jobs可以查看从终端启动的所有作业

3. 使进程回到前台：fg %作业编号。如果后台只有一个程序就不需要

4. 停止（暂停）进程：使用Ctrl-Z来暂停前台进程

## 信号
kill通常用来杀死进程， `kill PID` 。事实上kill是在发送信号，信号是操作系统和程序间通信的多种方式之一。比如我们按下Ctrl-C就是发送INT(Interrupt)信号。反过来，程序也在监听信号。

1. 使用kill发送<br>
    kill [ -signal ] PID<br>
    常用信号有(每个信号有自己的编号)<br>
    HUP 1 挂起，收到信号时程序重新读取配置文件<br>
    INT 2 中断<br>
    KILL 9 杀死，程序可以选择忽略收到的信号，但是KILL实际上不是真正地被发到程序，而是内核停止了进程。这种方式停止程序会让程序没有时间清理自己的工作或者保存工作。能不用就不用<br>
    TERM 15 终止信号，kill默认发送的信号,如果程序仍然有活力接受信号，就会被终止<br>
    CONT 18 继续运行，恢复接受STOP的程序<br>
    STOP 19 暂停<br>
使用kill -l来显示完整的信号列表

2. 使用killall命令发信号给多个进程<br>
killall [-u user] [-signal] name...<br>
给指定的程序或指定用户名的多个进程发信号

## 更多和进程相关的命令
进程监控是重要的系统管理任务，所以有很多命令来为它服务。<br>
pstree,树状进程列表。vmstat,资源使用情况。xload,绘制系统时间负载情况。tload,类似xload,但是在终端绘制

