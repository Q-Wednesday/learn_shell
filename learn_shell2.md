这里对应Linux命令行大全的第二部分！配置与环境
# 环境
尽管大多数程序使用配置文件来储存程序的设置，但是也有一些程序会查找环境中的变量来调整自己的行为。用户可以用环境来自定义shell

## 环境中储存的是什么
shell环境中储存了两种类型的数据，分别为环境变量和shell变量，不过它们在bash中没有什么区别。shell变量是bash存放的少量数据，环境变量就是除此之外的其他变量。除了变量之外shell也储存了一些编程数据(programmatic data)，也就是别名和shell函数。

1. 检查环境<br>
需要使用set或者printenv命令。set会显示shell变量和环境变量，printenv只显示环境变量。而且set的输出结果是按照字母顺序排列的。使用printenv 变量名 可以列出特定的值。如
    ```
    printenv USER
    ```
    想查看单个变量的值，也可以直接用<br>
    ```
    echo $HOME
    ```
    查看别名，使用不带参数的alias
    ```
    alias
    ```
2. 一些有趣的变量<nr>
环境中包含了许多变量比如SHELL就是本机shell名称，LANG是语言字符集，TZ为时区等等。需要的时候可以去查询

## 环境是如何建立的

用户登陆后bash启动并读取一系列启动文件。

1. login和non-login shell<br>
login shell即提示用户输入用户名和密码的绘画，如虚拟控制台会话。而在GUI中启动的终端就是non-login shell会话。
login shell读取一个或多个启动文件<br>
/etc/profile 适用于所有用户<br>
~/.bash_profile 用户个人启动文件，可以扩展或重写全局配置脚本<br>
~/bash_login 如果上面的文件缺失就读取这个<br>
~/.profile 上面两个文件都缺失才读取<br>

而non-login shell读取<br>
/etc/bash.bashrc 适用于所有用户<br>
~/.bashrc 用户个人启动文件<br>
除了读取上述文件，non-login shell会继承父进程的环境，父进程通常是一个login shell

2. 启动文件中有什么<br>
#开头的是注释。里面有一些脚本语言写的语句比如条件判断，赋值<br>
shell如何找到命令？在这些启动文件中会设置PATH的值

## 修改环境
知道了上面的知识，用户就可以自己修改启动文件来定义环境了

1. 修改哪些文件？

2. 文本编辑器<br>
为了编辑shell的启动文件，以及其他配置文件，我们都需要文本编辑器。为什么一个系统中会有那么多编辑器？因为程序员热衷于编写文本编辑器来拥有符合自己工作方式的工具。<br>
图形界面的编辑器有gedit(GNOME配备)，kedit,kwrite,kate(KDE配备)<br>
还有基于文本的编辑器，nano,vi和emacs。nano是很简易的，vi(现在一般都用vim了)是传统的文本编辑器。emacs是一个庞大的、万能的、可以做任何事情的编辑环境，尽管emacs仍然可以用，但是Linux系统很少默认安装emacs。

3. 使用nano<br>
Ctrl-X是退出程序，Ctrl-O是保存。

4. 激活更改<br>
只有在启动shell的时候才会读取配置文件，如果对配置文件进行了修改可以强制读取
    ```
    source .bashrc
    ```

# Vi
为什么要学习Vi?因为Vi总是可用的，当没有图形界面或者图形界面出错的时候Vi也能用。而且POSIX要求所有的系统都要配备Vi。Vi是轻量级的软件，运行很快。（还有一条是用户不想被其他的Linux喝UNIX用户蔑视hhh）

## VI背景
vi出自单词visual。在图形界面编辑器出现之前都是行编辑器的天下，用户每次只能编辑一行。vi的出现让全屏编辑成为可能。而大多数Linux发行版都配备的是vim(Vi Improved)。是传统的Vi的改良版。通常，vim的硬连接（或别名）指向Linux系统的vi名词。

## 启动和退出
退出是:q,强制退出:q!

## 编辑模式
1. 按I进入插入模式
2. :w写入（保存）

## 移动光标
HJKL对应左下右上<br>
0行头<br>
^ 本行第一个非空<br>
$ 本行末尾<br>
w 下一个单词/标点开头<br>
W 下一个单词开头<br>
b 上一个单词/标点开头<br>
B 上一个单词开头<br>
Ctrl-F or page down 下一页<br>
Ctrl-B or page up 上一页<br>
G 到最后一行<br>
数字加G 到第n行<br>

## 基本编辑
1. 添加文本<br>
由于光标不能跳出行末，所以用i无法在文本末直接添加，可以使用a,会跳到当前单词末尾开始。使用A可以跳到行末开始

2. 插入一行<br>
o在上方插入，O在下方插入。命令模式下u可以取消操作。

3. 删除文本<br>
X删除光标处的字符，x可以加上数字前缀可以明确删除数目.D则更普遍，d可以加数字前缀明确删除次数，此外还能控制删除范围。<br>
dd 当前行<br>
5dd 删除当前行和之后四行<br>
dW 删除当前字符到下一个字符开始<br>
d$ 删除当前字母到行尾<br>
d0 删除当前字符到行开头<br>
d^ 删除当前字符到下一个非空<br>
dG 删除当前行到文件结尾<br>
d20G 删除当前行到第20行<br>

4. 剪切，复制，粘贴<br>
d并不只是删除，而是剪切。y可以复制文本.p是粘贴到光标之后，P粘贴到光标之前。<br>
yy 当前行
<br>...<br>
其他含义可以参考之前的删除文本那里，是一样的（指定范围）

5. 合并行<br>
光标在第三行，输入J，那么第四行会并入第三行

## 查找和替换
1. 行内搜索<br>
命令f,比如fa会移动到下一个出现a的地方。执行过一次搜索后输入;跳到下一个结果，按,到上一个结果.

2. 搜索整个文件<br>
和less一样，使用/完成搜索。使用n查找下一个

3. 全局搜索和替换<br>
使用如下命令<br>
:%s/Line/line/g<br>
%指定范围，表示全部，也可以写为1,$。s为操作：搜索和替换。/Line/line为把Line替换为line,g表示全局，就是搜索到的所有都替换。若改为<br>
:%s/Line/line/gc<br>
会让用户每次替换前进行确认。给出的提示选项有：y替换，n跳过这个，a替换这个到之后所有，q或ESC停止替换，l执行本次之后退出替换，Ctrl-E/Ctrl-Y是向上和向下滚动来查看上下文。

## 编辑多个文件<br>
vim file1 file2 ... 打开多个文件。
1. 切换文件<br>
:n切换到下一个，:N上一个。切换文件必须要求先对当前文件的更改进行保存。如果放弃更改强行切换，使用:n!即可。除了这些方法，还可以使用:buffers来查看正在编辑的文件列表，输入:buffers加编号可以切换到另一个文件.

2. 载入更多文件<br>
使用:e(edit的简写)可以载入更多文件。

3. 文件间内容复制<br>
直接使用之前的复制粘贴

4. 插入整个文件<br>
:r(read简写) 文件名<br>
会把指定内容插入到光标之前。

## 保存工作
:w 文件名 保存工作。如果以新的名称保存工作就相当于另存为，保存后继续编辑的话，还是编辑原来的文件而不是新存的！

# 定制提示符
shell的可配置性是很高的，可以自己定义自己的提示符

## 提示符分解
提示符由名为PS!(prompt string 1)的环境变量定义，可以用echo来查看值.里面有一些奇怪的转移字符，是shell提示符用的，有一个表可以查。比如\@是格式为AM/PM的当前时间。

## 设计提示符
可以直接修改变量PS1来实现。如果提示符为空，就没有任何提示。加上一个最简单的\$:管理员提示#，非管理员提示$.

## 添加颜色
由发送到终端仿真器的ANSI转义代码控制，该转义代码会嵌入到字符流中，会被终端解释为命令。如黑色是\033[0;30m]

## 移动光标
通过这些代码可以构建提示符，让提示符出现的时候在屏幕上方绘制彩色横条等，不过这样提示符编码看起来会有点可怕。

## 保存提示符
放到配置文件如.bashrc中即可
